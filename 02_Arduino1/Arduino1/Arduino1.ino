/***********************************************************************/
/*                                                                     */
/*  FILE        :Arduino1.ino                                          */
/*  DATE        :May 10, 2020                                          */
/*  DESCRIPTION :ROSロボ Arduino1用プログラム                          */
/*                                                                     */
/*  This file is generated by Tatsuya Miyazaki                         */
/*                                                                     */
/***********************************************************************/
#include <ros.h>
#include <geometry_msgs/Twist.h>
#include <std_msgs/Int32.h>
#include <std_msgs/UInt32.h>
#include <std_msgs/Bool.h>

#include "fix.hpp"
#include "CTimer.hpp"
#include "CMotor.hpp"
#include "CBumper.hpp"
#include "CComArduinos.hpp"
#include "SpeedController.hpp"
#include "COdometry.hpp"
#include "CAccelController.hpp"

/***********************************************************************/
/*                           グローバル変数                            */
/***********************************************************************/

// ROSからの速度指令
static geometry_msgs::Twist gArduinoCmdVel;


/***********************************************************************/
/*                               ROS関数                               */
/***********************************************************************/
ros::NodeHandle nh;

//-------------------------------------------------------
//             cmd_velのサブスクライバー
//-------------------------------------------------------
#define WHEEL_TRACK 0.0625f // 車輪左右間隔[m]
#define MAX_VELOCITY 0.7f // デューティ100％の時の速度[m/s]
#define R_MOTOR_SPEC 1.0f // モーターの固有ばらつき補正値
#define L_MOTOR_SPEC 1.0f // モーターの固有ばらつき補正値
//#define L_MOTOR_SPEC 0.98f
#define DUTY_MIN 15       // モーターが回転し始める最小のDUTY比

// arduino_cmd_velが更新されたときに呼び出される関数
void messageCb2(const geometry_msgs::Twist& twist) {
  gArduinoCmdVel.linear.x = twist.linear.x;
  gArduinoCmdVel.angular.z = twist.angular.z;
}

// cmd_velを取得するサブスクライバー
ros::Subscriber<geometry_msgs::Twist> sub2("arduino_cmd_vel", &messageCb2);

//-------------------------------------------------------
//         バンパーステータスののパブリッシャー
//-------------------------------------------------------
// バンパートピック
std_msgs::Bool bumper_msg;
ros::Publisher pubBumper("Bumper", &bumper_msg);

//-------------------------------------------------------
//         エンコーダカウントのパブリッシャー
//-------------------------------------------------------
// エンコーダデータ
std_msgs::Int32 encR_msg;
std_msgs::Int32 encL_msg;
std_msgs::UInt32 time_msg;

//Publisherのインスタンス
//トピック名：encR, encL, time_A2
ros::Publisher pub3("A2_encR", &encR_msg);
ros::Publisher pub4("A2_encL", &encL_msg);
ros::Publisher pub5("A2_time", &time_msg);

/***********************************************************************/
/*                               main関数                              */
/***********************************************************************/
void setup() {
  //Serial.begin(115200);
  delay(1000);
}

void loop() {
  // モータークラス
  static CMotor gm;
  // バンパークラス
  static CBumper gb;
  // タイマークラス
  static CTimer bpTimer(BUMPER_CYCLE_TIME); // バンパー用
  static CTimer spTimer(PID_CYCLE_TIME);    // 速度制御用
  static CTimer rosTimer(50);               // rosserial用
  // Arduino間通信クラス
  static CComArduinos gc(SLAVE);
  //速度制御インスタンス生成
  static SpeedController spR;
  static SpeedController spL;
  // 加速制御
  static CAccelController acR(PID_CYCLE_TIME);
  static CAccelController acL(PID_CYCLE_TIME);

  static uint8_t encUpdFlag = 0;

  // エンコーダ値更新処理
  if (gc.isI2Crecieved()) {
    gc.i2cSlaveRecieve();
    #ifdef ENCODER_REVERSE_RIGHT
    gc.A2state.encR *= -1;
    #endif
    #ifdef ENCODER_REVERSE_LEFT
    gc.A2state.encL *= -1;
    #endif
    encUpdFlag++;
  }

  // バンパーのサンプリング(CBumper.hppのBUMPER_SAMPLE_FREQ [Hz]で実行)
  if (bpTimer.isCycleTime()) {
    gb.bumperSampling();
  }

  // 速度制御
  if (spTimer.isCycleTime()) {
    //現在速度の計算
    spR.calcVelocity(gc.A2state.encR, gc.A2state.time);
    spL.calcVelocity(gc.A2state.encL, gc.A2state.time);
    //加速制御
    acR.setTargetVelocity(
      COdometry::twist2velocityR(
        FLOAT_TO_FIX(gArduinoCmdVel.linear.x),
        FLOAT_TO_FIX(gArduinoCmdVel.angular.z)
      )
    );
    acR.accelSpeed();
    acL.setTargetVelocity(
      COdometry::twist2velocityL(
        FLOAT_TO_FIX(gArduinoCmdVel.linear.x),
        FLOAT_TO_FIX(gArduinoCmdVel.angular.z)
      )
    );
    acL.accelSpeed();
    //目標速度の設定
    spR.setTargetVelocity(acR.getPresentVelocity());
    spL.setTargetVelocity(acL.getPresentVelocity());
    //PID制御
    spR.controlMotorsSpeed();
    spL.controlMotorsSpeed();
    //モーターにデューティ比を指令
    gm.driveMotors(spR.getDuty(), spL.getDuty());
  }

  // ROSへの周期的なパブリッシュ
  if (rosTimer.isCycleTime()) {
    if (!nh.connected()) {   // rosserialが切れたら、再接続する
      nh.getHardware()->setBaud(115200);
      nh.initNode();
      nh.subscribe(sub2);
      nh.advertise(pubBumper);
      nh.advertise(pub3);
      nh.advertise(pub4);
      nh.advertise(pub5);
      //Serial.print("reconnecting");
      while (!nh.connected()) {
        //Serial.print(".");
        nh.spinOnce();
        digitalWrite(30,LOW);   // 接続できないときはLEDを点滅させる
        delay(500);
        digitalWrite(30,HIGH);
        delay(500);
      }
      //Serial.println("Connect.");
    } else {                    // rosserialが接続しているときの動作
      digitalWrite(30,HIGH);    // LED消灯
      // バンパー値をパブリッシュ
      if (gb.isBumperChanged()) {
        bumper_msg.data = gb.readBumper();
        pubBumper.publish(&bumper_msg);
      }

      // エンコーダ値をパブリッシュ
      if (encUpdFlag) {
        encUpdFlag = 0;
        encR_msg.data = gc.A2state.encR;
        encL_msg.data = gc.A2state.encL;
        time_msg.data = gc.A2state.time;
        pub3.publish(&encR_msg);
        pub4.publish(&encL_msg);
        pub5.publish(&time_msg);
      }
    }
  }
  nh.spinOnce();
}
