/***********************************************************************/
/*                                                                     */
/*  FILE        :CComArduinos.cpp                                      */
/*  DATE        :Jul. 11, 2020                                         */
/*  DESCRIPTION :ROSロボ Arduino1-Arduino2間通信用プログラム           */
/*                                                                     */
/*  This file is generated by Tatsuya Miyazaki                         */
/*                                                                     */
/***********************************************************************/

#ifndef _CCOM_ARDUINOS_CPP__
#define _CCOM_ARDUINOS_CPP__

#include "CComArduinos.hpp"

/***********************************************************************/
/*                    Arduino1-Arduino2間通信                          */
/***********************************************************************/
// スレーブ受信フラグ
static uint8_t CComArduinos::i2cRecievedFlag = 0;
// スレーブ側の受信割込み動作（Arduino1）
static void i2cRecieveInterrupt(int numBytes) {
  CComArduinos::i2cRecievedFlag++;
}

// 初期化
CComArduinos::CComArduinos(uint8_t select) {
  if (select == SLAVE) {
    //Serial.println("I2C Slave!");
    Wire.begin(8);                // join i2c bus with address #8
    Wire.onReceive(i2cRecieveInterrupt); // register event
  } else if (select == MASTER) {
    //Serial.println("I2C Master!");
    Wire.begin(); // join i2c bus (address optional for master)
  }
  // 待ち行列の初期化
  queueCode2.data = bufCode2;
  queueCode2.size = SIZE_OF_CODE2 + 1;
  queueCode2.front = 0;
  queueCode2.rear = 0;
  // Arduino2状態量の初期化
  A2state.encR = 0;
  A2state.encL = 0;
  A2state.time = 0;
}

// 32bitのデータを変換する
uint8_t CComArduinos::encode32bit(int32_t data) {
  int32uType temp;

  temp.cnt32 = data;
  // 上位から7bitずつ抽出して待ち行列に追加する
  if (!enqueue(&queueCode2, temp.cnt7.b31to25)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b24to18)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b17to11)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b10to04)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b03to00 << 3)) return(0);
  return(1);
}

// 符号なし32bitのデータを変換する
uint8_t CComArduinos::encodeU32bit(uint32_t data) {
  uint32uType temp;

  temp.cnt32 = data;
  // 上位から7bitずつ抽出して待ち行列に追加する
  if (!enqueue(&queueCode2, temp.cnt7.b31to25)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b24to18)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b17to11)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b10to04)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b03to00 << 3)) return(0);
  return(1);
}


// 現在のエンコーダ値（encRとencL）を変換して待ち行列に追加する
uint8_t CComArduinos::encode2(arduino2StateType a2st) {
  // STXを待ち行列に追加する
  if (!enqueue(&queueCode2, STX)) return(0);
  
  // encRを待ち行列に追加する
  if (!encode32bit(a2st.encR)) return(0);

  // encLを待ち行列に追加する
  if (!encode32bit(a2st.encL)) return(0);

  // timeを待ち行列に追加する
  if (!encodeU32bit(a2st.time)) return(0);
  //if (!encode32bit(a2st.time)) return(0);

  // ETXを待ち行列に追加する
  if (!enqueue(&queueCode2, ETX)) return(0);

  return(1);
}

// 変換された32bitのデータを復元する
uint8_t CComArduinos::decode32bit(int32_t *data) {
  int32uType temp;

  // 上位から7bitずつ復元する
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b31to25 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b24to18 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b17to11 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b10to04 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b03to00 = dequeue(&queueCode2) >> 3;

  *data = temp.cnt32;
  return(1);
}

// 変換された符号なし32bitのデータを復元する
uint8_t CComArduinos::decodeU32bit(uint32_t *data) {
  uint32uType temp;

  // 上位から7bitずつ復元する
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b31to25 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b24to18 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b17to11 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b10to04 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b03to00 = dequeue(&queueCode2) >> 3;

  *data = temp.cnt32;
  return(1);
}

// 受信したバイナリデータをエンコーダ値（encRとencL）に復元する
uint8_t CComArduinos::decode2(arduino2StateType *a2st) {
  uint8_t rxData;
  arduino2StateType tempSt = {0, 0, 0};

  while(!isQueueEmpty(&queueCode2)) {
    rxData = dequeue(&queueCode2);
    if (rxData == STX) {
      if (!decode32bit(&tempSt.encR)) return(0);
      if (!decode32bit(&tempSt.encL)) return(0);
      if (!decodeU32bit(&tempSt.time)) return(0);
      if (isQueueEmpty(&queueCode2)) return(0);
      rxData = dequeue(&queueCode2);
      if (rxData == ETX) {
        a2st->encR = tempSt.encR;
        a2st->encL = tempSt.encL;
        a2st->time = tempSt.time;
        return(1);
      }
    }
  }
  return(0);
}


// マスター側の送信動作（Arduino2）
uint8_t CComArduinos::i2cMasterTransmit(void) {
  uint8_t size = 0;
  while (!isQueueEmpty(&queueCode2)) {
    dequeue(&queueCode2);
  }
  encode2(A2state);
  Wire.beginTransmission(8); // transmit to device #8
  while(!isQueueEmpty(&queueCode2)) {
    byte c = dequeue(&queueCode2); // receive byte as a character
    Wire.write(c);
    size++;
  }
  Wire.endTransmission();    // stop transmitting
  return(size);
}


// I2Cで受信データが更新されたかどうか
uint8_t CComArduinos::isI2Crecieved(void) {
  return(i2cRecievedFlag);
}

// スレーブ側の受信動作（Arduino1）
uint8_t CComArduinos::i2cSlaveRecieve(void) {
  i2cRecievedFlag = 0;
  while (!isQueueEmpty(&queueCode2)) {
    dequeue(&queueCode2);
  }
  while (Wire.available()) { // loop through all
    byte c = Wire.read(); // receive byte as a character
    if (!enqueue(&queueCode2, c)) return(0);
  }
  if(!decode2(&A2state)) {  // エンコーダ値を更新
    //Serial.println("failed to decode2");
    return(0);
  }
  return(1);
}


#endif  // _CCOM_ARDUINOS_CPP__
