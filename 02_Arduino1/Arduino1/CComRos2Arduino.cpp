/***********************************************************************/
/*                                                                     */
/*  FILE        :CComRos2Arduino.cpp                                   */
/*  DATE        :Jul. 11, 2020                                         */
/*  DESCRIPTION :ROS2-Arduino1間通信用プログラムヘッダ                   */
/*                                                                     */
/*  This file is generated by Tatsuya Miyazaki                         */
/*                                                                     */
/***********************************************************************/


#include "CComRos2Arduino.hpp"

/***********************************************************************/
/*                       ROS2-Arduino1間通信                           */
/***********************************************************************/
// 初期化
CComRos2Arduino::CComRos2Arduino() {
  m_ard2rosData.delta_t = 0;
  m_ard2rosData.delta_enc_r = 0;
  m_ard2rosData.delta_enc_l = 0;

  m_ros2ardData.velocity_x = 0.0;
  m_ros2ardData.omega_z = 0.0;
  
  // 待ち行列の初期化
  rxQueue.data = rxBuf;
  rxQueue.size = RX_BUF_SIZE;
  rxQueue.front = 0;
  rxQueue.rear = 0;

  begin();
}

// シリアルポートオープン
void CComRos2Arduino::begin(void) {
  Serial1.begin(115200);
}

// ROSへ送信する状態量を更新する
void CComRos2Arduino::updateArd2RosData(
  uint32_t delta_t, int32_t delta_enc_r, int32_t delta_enc_l, bool bumper
) {
  m_ard2rosData.delta_t = delta_t;
  m_ard2rosData.delta_enc_r = delta_enc_r;
  m_ard2rosData.delta_enc_l = delta_enc_l;
  m_ard2rosData.bumper = bumper;
}

// ゲッター
float CComRos2Arduino::getVelocityX(void) {
  return(m_ros2ardData.velocity_x);
}

float CComRos2Arduino::getOmegaZ(void) {
  return(m_ros2ardData.omega_z);
}

// 文字列を送信する
void CComRos2Arduino::myputs(String msg) {
  Serial1.print(msg);
}

// 文字を受信する
char CComRos2Arduino::mygetchar(void) {
  return Serial1.read();
}

// 文字列を受信する
// endChar：この文字まで読み込む
// *str：文字列を格納するchar配列
// size：strバッファのサイズ
// 戻り値：true：受信成功、false：未受信
bool CComRos2Arduino::readUntil(char endChar, char *str, uint8_t size) {
  while(Serial1.available()) {
    char rxChar = mygetchar();
    if(isQueueFull(&rxQueue)) {
      // 待ち行列がいっぱいのときは、古いデータから捨てる
      dequeue(&rxQueue);
    }
    // 受信データを待ち行列に格納する
    enqueue(&rxQueue, rxChar);

    // 終端文字まで受信したら
    if (rxChar == endChar) {
      uint8_t i = 0;
      while(!isQueueEmpty(&rxQueue)) {
        str[i] = dequeue(&rxQueue);
        i++;
        // バッファオーバーフロー対策
        if (i >= size - 1) {
          break;
        }
      }
      str[i] = '\0';  // 末尾にnull文字設定
      return(true);
    }
  }
  return(false);
}

// 受信処理
// 戻り値：true：受信成功、false：未受信
bool CComRos2Arduino::rxProcess(void) {
  char str[RX_BUF_SIZE] = "";
  // 受信バッファチェック
  if (readUntil(R2A_ETX, str, RX_BUF_SIZE)) {
    // 1行受信完了したとき
    CLog::debug(str);
    // 冒頭文字列チェック
    if (String(strtok(str, ",")).equals(R2A_STX)) {
      // x方向速度[m/s]
      m_ros2ardData.velocity_x = String(strtok(NULL, ",")).toFloat();
      // z方向角速度[rad/s]
      m_ros2ardData.omega_z = String(strtok(NULL, ",")).toFloat();
      return (true);
    }
  }
  return (false);
}

// 状態通知送信
void CComRos2Arduino::txProcess(void) {
  String txMsg = String(A2R_STX);
  txMsg += ",";
  txMsg += String(m_ard2rosData.delta_t);
  txMsg += ",";
  txMsg += String(m_ard2rosData.delta_enc_r);
  txMsg += ",";
  txMsg += String(m_ard2rosData.delta_enc_l);
  txMsg += ",";
  txMsg += String(m_ard2rosData.bumper);
  txMsg += ",";
  txMsg += String(A2R_ETX);
  myputs(txMsg);
}

