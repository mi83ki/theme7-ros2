/***********************************************************************/
/*                                                                     */
/*  FILE        :SpeedController.cpp                                   */
/*  DATE        :Jul 11, 2020                                          */
/*  DESCRIPTION :速度制御クラス                                        */
/*                                                                     */
/*  This file is generated by Hideaki Shimada                          */
/*                            Tatsuya Miyazaki                         */
/*                                                                     */
/***********************************************************************/

#include "SpeedController.hpp"

SpeedController::SpeedController()
{
  last_time = 0;
  last_enc = 0;
  //PIDパラメータの設定
  //initPID(&pid_state, KTT, &velocity, 0, SC_KP, SC_TI, SC_TD);
  initPID(&pid_state, KKK, &velocity, 0, SC_KP, SC_KI, SC_KD);
}

SpeedController::~SpeedController()
{
  ;
}

//arduino2のエンコーダ値と時間からタイヤの速度[m/s][rad/s]を更新する
const fix SpeedController::myPI = FLOAT_TO_FIX(M_PI);
const fix SpeedController::myTireDiameter = FLOAT_TO_FIX(TIRE_DIAMETER);
const fix SpeedController::myGearRagtio = INT_TO_FIX(GEAR_RATIO);
const fix SpeedController::myEncoderPulse = INT_TO_FIX(ENCODER_PULSE);
const fix SpeedController::myRotationCount = FIX_MUL(myGearRagtio, myEncoderPulse);
void SpeedController::calcVelocity(int32_t enc, uint32_t time) {
  fix diff_time = 0;           // [s]
  fix diff_enc = 0;            // エンコーダ増分

  if (last_time == 0) {
    // 初回起動時は無視する
    omega = 0;
    velocity = 0;
  } else {
    //前回との差分の積算
    diff_time = INT_TO_FIX(time - last_time) / 1000;
    diff_enc = enc - last_enc;
  
    //角速度の計算
    omega = 2 * FIX_MUL(INT_TO_FIX(diff_enc), myPI);
    omega = FIX_DIV(omega, FIX_MUL(myRotationCount, diff_time));
  
    //速度の計算
    velocity = FIX_MUL(omega, (myTireDiameter / 2));
}

  //現在の値を保持
  last_enc = enc;
  last_time = time;
}

//受け取った目標速度にするためにトルクを計算してモーターを制御する
const fix SpeedController::myResistance = FLOAT_TO_FIX(RESISTANCE);
const fix SpeedController::myKrTorque = FLOAT_TO_FIX(KR_TORQUE);
const fix SpeedController::myKeVolt = FLOAT_TO_FIX(KE_VOLT);
const fix SpeedController::myMaxVolt = FLOAT_TO_FIX(MAX_VOLT);
const fix SpeedController::myDutyResolution = INT_TO_FIX(DUTY_RESOLUTION_);
const fix SpeedController::myVoltage2Duty = FIX_DIV(myDutyResolution, myMaxVolt);
const int16_t SpeedController::myPIDfreq = 1000 / PID_CYCLE_TIME;
const fix SpeedController::myIntegMax = FIX_DIV(FIX_MUL(myMaxVolt, myKrTorque), myResistance);
int16_t SpeedController::controlMotorsSpeed(void) {
  if (isEnable(pid_state)) {
    fix duty = 0;
    // PID制御量を計算
    fix torque_pid = pidControl(&pid_state, myPIDfreq);   
    // 積分項のカットオフ
    integErrCutoff(&pid_state, myIntegMax, -1 * myIntegMax);
    //デューティ比計算
    duty = FIX_MUL(myResistance, torque_pid);
    duty = FIX_DIV(duty, myKrTorque);
    duty += FIX_MUL(myKeVolt, omega);
    duty = FIX_MUL(duty, myVoltage2Duty);
  
    //デューティ比の最大・最小値制限
    fixcutoff(&duty, INT_TO_FIX(100), -INT_TO_FIX(100));
  
    //デューティ比をint型に変換
    setDuty(FIX_TO_INT(duty));
  } else {
    setDuty(0);
  }
  return(getDuty());
}


int16_t SpeedController::getDuty(void) {
  return(duty_int);
}

void SpeedController::setDuty(int16_t duty) {
  // 速度が一定以下の場合、デューティ比の最大値を制限する（電流不足によるシャットダウン防止）
  if ((getPresentVelocity() < LOW_SPEED) &&
      (getPresentVelocity() > -LOW_SPEED)) {
    if (duty > DUTY_LOW_SPEED) {
      duty = DUTY_LOW_SPEED;
    } else if (duty < -DUTY_LOW_SPEED) {
      duty = -DUTY_LOW_SPEED;
    }
  }
  duty_int = duty;
}

float SpeedController::getPresentVelocity(void) {
  return(FIX_TO_FLOAT(velocity));
}

float SpeedController::getTargetVelocity(void) {
  return(FIX_TO_FLOAT(pid_state.desired));
}

void SpeedController::setTargetVelocity(fix targetVelocity) {
  if (targetVelocity == 0) {
    pid_state.desired = targetVelocity;
    stopPID(&pid_state);
    setDuty(0);
  } else {
    if (isEnable(pid_state)) {
      setPIDtarget(&pid_state, targetVelocity);
    } else {
      startPID(&pid_state, targetVelocity);
    }
  }
}


