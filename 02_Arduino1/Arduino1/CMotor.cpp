/***********************************************************************/
/*                                                                     */
/*  FILE        :CMotor.hpp                                            */
/*  DATE        :Jul 04, 2020                                          */
/*  DESCRIPTION :モータークラス                                        */
/*                                                                     */
/*  This file is generated by Tatsuya Miyazaki                         */
/*                                                                     */
/***********************************************************************/

#ifndef _CMOTOR_CPP__
#define _CMOTOR_CPP__

#include "CMotor.hpp"

/***********************************************************************/
/*                           モーター関数                              */
/***********************************************************************/
// モーターの初期化
CMotor::CMotor(void) {
  //------------------------
  //  PIN設定
  //------------------------
  pinMode(MOTOR_AIN1_PIN, OUTPUT );
  pinMode(MOTOR_AIN2_PIN, OUTPUT );
  pinMode(MOTOR_PWMA_PIN, OUTPUT );
  pinMode(MOTOR_BIN1_PIN, OUTPUT );
  pinMode(MOTOR_BIN2_PIN, OUTPUT );
  pinMode(MOTOR_PWMB_PIN, OUTPUT );

  //------------------------
  //  出力初期化
  //------------------------
  digitalWrite(MOTOR_AIN1_PIN, LOW);  // A1出力を0に
  digitalWrite(MOTOR_AIN2_PIN, LOW);  // A2出力を0に
  digitalWrite(MOTOR_BIN1_PIN, LOW);  // B1出力を0に
  digitalWrite(MOTOR_BIN2_PIN, LOW);  // B2出力を0に

  //------------------------
  //  タイマカウンタ1の設定
  //------------------------
  TCCR1A = (1 << COM1A1) | (1 << COM1B1); // 比較一致でLow、BOTTOMでHighをOC1xﾋﾟﾝへ出力 (非反転動作)
  TCCR1A |= (1 << WGM11);               // 高速PWM動作（TOP値：ICR1）
  TCCR1B = (1 << WGM13) | (1 << WGM12); // 高速PWM動作（TOP値：ICR1）
  OCR1A = PWM_RESOLUTION;               // 初期値
  OCR1B = PWM_RESOLUTION;               // 初期値
  ICR1 = PWM_RESOLUTION - 1;            // 8MHz or 16MHzクロック前置分周なしで1kHzのPWM波形＆割込み生成
  TCCR1B |= (1 << CS10);                // 前置分周なしでタイマースタート
}

//-------------------------------------------------------
// Function : driveMotors
// 引数     : dutyR : 右モーターの電圧[％]（-100%～100%）
//            dutyL : 左モーターの電圧[％]（-100%～100%）
//-------------------------------------------------------
void CMotor::driveMotors(int16_t dutyR, int16_t dutyL) {
  //------------------------
  // 右モーター
  //------------------------
  if (dutyR > 0) {                              // 正転させるとき
    digitalWrite(MOTOR_AIN1_PIN, HIGH);
    digitalWrite(MOTOR_AIN2_PIN, LOW);          // CW
  } else if (dutyR == 0) {
    digitalWrite(MOTOR_AIN1_PIN, LOW);
    digitalWrite(MOTOR_AIN2_PIN, LOW);          // フリーストップ
  } else {                                      // 逆転させるとき
    dutyR *= -1;
    digitalWrite(MOTOR_AIN1_PIN, LOW);
    digitalWrite(MOTOR_AIN2_PIN, HIGH);         // CCW
  }
  if (dutyR > DUTY_RESOLUTION) {                // 指定値がオーバーフローしているとき
    dutyR = DUTY_RESOLUTION;
  } else if (dutyR > 0) {
    dutyR *= PWM_RESOLUTION / DUTY_RESOLUTION;  // PWMの分解能領域に投影
    OCR1A = dutyR - 1;                          // PWM波形の設定
  } else {
    OCR1A = PWM_RESOLUTION;
  }

  //------------------------
  // 左モーター
  //------------------------
  if (dutyL > 0) {                              // 正転させるとき
    digitalWrite(MOTOR_BIN1_PIN, LOW);
    digitalWrite(MOTOR_BIN2_PIN, HIGH);         // CCW
  } else if (dutyL == 0) {
    digitalWrite(MOTOR_BIN1_PIN, LOW);
    digitalWrite(MOTOR_BIN2_PIN, LOW);          // フリーストップ
  } else {                                      // 逆転させるとき
    dutyL *= -1;
    digitalWrite(MOTOR_BIN1_PIN, HIGH);
    digitalWrite(MOTOR_BIN2_PIN, LOW);          // CW
  }
  if (dutyL > DUTY_RESOLUTION) {                // 指定値がオーバーフローしているとき
    dutyL = DUTY_RESOLUTION;
  } else if (dutyL > 0) {
    dutyL *= PWM_RESOLUTION / DUTY_RESOLUTION;  // PWMの分解能領域に投影
    OCR1B = dutyL - 1;                          // PWM波形の設定
  } else {
    OCR1B = PWM_RESOLUTION;
  }
}

// モーターを止めたいとき
void CMotor::stopMotors(void) {
  OCR1A = PWM_RESOLUTION;
  OCR1B = PWM_RESOLUTION;
  digitalWrite(MOTOR_BIN1_PIN, LOW);
  digitalWrite(MOTOR_BIN2_PIN, LOW);            // フリーストップ
}

#endif  // _CMOTOR_CPP__
